UPDATE_GLOBAL_ITER = 50
GAMMA = 0.99
MAX_EP = 10000
MAX_EP_STEP = 100
LEARNING_RATE = 0.0003
NUM_WORKERS = mp.cpu_count()

# Model IO Parameters
MODEL_NAME = "stand_net"
LOAD_MODEL = False
TEST_MODEL = False

# Neural Network Architecture Variables
ENV_DUMMY = Environment()
N_S, N_A = ENV_DUMMY.state_dim, ENV_DUMMY.action_dim
Z1 = 200
Z2 = 100
MU_SPAN = 1


    def __init__(self, s_dim, a_dim):
        super(Net, self).__init__()
        self.s_dim = s_dim
        self.a_dim = a_dim
        self.a1 = nn.Linear(s_dim, Z1)
        self.a2 = nn.Linear(Z1, Z2)
        self.mu = nn.Linear(Z2, a_dim)
        self.sigma = nn.Linear(Z2, a_dim)
        self.c1 = nn.Linear(s_dim, Z1)
        self.c2 = nn.Linear(Z1, Z2)
        self.v = nn.Linear(Z2, 1)
        set_init([self.a1, self.a2, self.mu, self.sigma, self.c1, self.c2, self.v])
        self.distribution = torch.distributions.Normal

    def forward(self, x):
        a1 = F.relu6(self.a1(x))
        a2 = F.relu6(self.a2(a1))
        # mu = MU_SPAN * torch.tanh(self.mu(a2))
        mu = self.mu(a2)
        sigma = F.softplus(self.sigma(a2))
        c1 = F.relu6(self.c1(x))
        c2 = F.relu6(self.c2(c1))
        values = self.v(c2)
        return mu, sigma, values

    def demap_state(self, state, acc, gyr, pos, orr, velocities, target, time):
        tmp = [state[s]for s in self.ACTION_KEYS]
        tmp = tmp + list(velocities)
        tmp = tmp + list(target)
        # tmp = tmp + list(acc)
        # tmp = tmp + list(gyr)
        # tmp = tmp + list(pos)
        # tmp = tmp + [orr]
        tmp = tmp + [time - self.init_time - self.FRAME_TIME]  
        tmp = (np.array(tmp) - self.DEFAULT_STATE_MIN)/ self.DEFAULT_STATE_RANGE         
        return tmp